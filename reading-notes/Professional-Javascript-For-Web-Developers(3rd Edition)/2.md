## 第六章 面向对象的程序设计
关于对象的定义: 无序属性的集合,其属性可以包含基本值,对象或者函数.也就是说对象是一组没有特定顺序的值.  

#### 理解对象
对象数据属性(property)具有的特性(attribute)有:
+ [[Configurable]] 是否能通过delete删除属性从而重新定义属性,默认为true
+ [[Enumerable]] 是否能通过for-in循环返回属性,默认为true
+ [[Writable]] 能否修改属性的值,默认为true
+ [[Value]] 属性的数据值,默认为undefined

访问器属性,getter和setter函数,getter用来读取,setter用来写入,其特性有:
+ [[Configurable]] 表示是否能够通过delete删除属性从而重新定义属性.默认为true
+ [[Enumerable]] 表示是否能通过for-in循环返回属性,默认为true
+ [[Get]] 在读取属性的时候调用的函数,默认为undefined
+ [[Setter]] 在写入属性的时候调用的函数,默认为undefined

访问器属性不能直接定义,只能通过`Object.defineProperty()`来定义.
```javascript
var book= {
  _year:2004,
  edition:1
};
Object.defineProperty(book,'year',{
  get: function(){
    return this._year;
  },
  set: function(newValue){
    if(newValue > 2004){
      this._year =newValue;
      this.edition += newValue - 2004;
    }
  }
});
book.year=2005;
book.edition; // 2
```
定义多个属性:
```javascript
//
var book = {};
Object.defineProperties(book,{
  _year: {
    value: 2004,
  },
  edition: {
    value: 1,
  },
  year:{
    get: function(){
      return this._year;
    },
    set: function(newValue){
      if(newValue > 2004){
        this._year = newValue;
        this.edition += newValue -2004;
      }
    }
  }
});
```

#### 创建对象

###### 工厂模式
一种广为人知的设计模式,其抽象了创建具体对象的过程.工厂模式解决了创建多个相似对象的问题,但是却没有解决对象识别的问题.
```JavaScript
function createPerson(name,age,job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function(){
    alert(this.name);
  }
  return o;
}
var person1 = createPerson('Nicholas',29,"Software Engineer");
var person2 = createPerson('Greg',33,"Doctor");
```

###### 构造函数模式
构造模式可以创建特定类型的对象.
+ 构造函数跟一般函数并没有什么区别
+ 构造函数的主要问题是每个方法都要在每个实例上重新创建一遍
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function(){
    alert(this.name);
  }
}
var person1 = new Person('Nicholas',29,"Software Engineer");
var person2 = new Person('Greg',33,'Doctor');
```

###### 原型模式
我们创建的每一个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象,而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法.使用原型模式的好处是可以让所有对象实例共享它所包含的属性和方法.
```javascript
function Person(){}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software engineer';
Person.prototype.sayName = function(){
  alert(this.name);
};

var person1 = new Person();
person1.sayName(); // Nicholas
var person2 = new Person();
person2.sayName(); // Nicholas
alert(person1.sayName == person2.sayName); // true

// Object.getPrototypeOf() 用来获取一个对象的原型
Object.getPrototypeOf(person1) == Person.prototype; // true

// 实例定义的属性或者方法可以覆盖原型中的同名属性或者方法

// 原型与in操作符
// in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例或者原型中
"name" in person1; // true

// 可以用for-in 来枚举对象的属性(可枚举的属性),但是ECMAScript 5中有更好的获取方法Object.keys()
Object.keys(person1);

// 更简单的原型语法
function Person(){}
Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  syaName: function(){
    alert(this.name);
  }
};

// 实例的原型仅指向原型,而不是指向构造函数
// javascript中所有原生的引用类型都是使用原型模式创建,比如 Object,Array,String

// 原型模式的缺点
// 原型中的所有属性被很多实例共享,对于包含基本值得属性影响不大,但是对于那些包含引用类型值得属性来说,问题非常突出
// 一个实例修改该引用类型的属性,会导致其他实例上该属性值同步发生变化,因为部分实例有属于自己的属性
// 这也导致了很少有人单独使用原型模式

```
###### 组合使用构造函数模式和原型模式
在这种模式下,构造函数模式用来定义实例属性,而原型模式用来定义方法和共享属性,结果每个实例都会有自己的一份实例属性的副本,但同时又共享着对方的引用,最大限度的节省了内存.该模式是目前在ECMAScript中使用最广泛,认同度最高的一种创建自定义对象的方法.
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.friends = ['Shelby','Court'];
}
Person.prototype = {
  constructor : Person,
  sayName : function(){
    alert(this.name);
  }
};

var person1 = new Person('Nicholas',29,'Software Engineer');
var person2 = new Person('Greg',27,'Doctor');

person1.friends.push('Van');
person1.friends; // ["Shelby", "Court", "Van"]
person2.friends; // ["Shelby", "Court"]
```

###### 动态原型模式
把所有的信息都封装在构造函数中,比较完美,不过不能用对象字面量重写原型.
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;

  if(typeof this.sayName != 'function'){
    Person.prototype.sayName = function(){
      alert(this.name);
    };
  }
}
```

###### 寄生构造函数模式
用的不多,不在介绍

###### 稳妥构造函数模式
用的不都,听说很安全,适合在某些安全执行环境中使用,这里不在介绍了
