## 第六章 面向对象的程序设计
关于对象的定义: 无序属性的集合,其属性可以包含基本值,对象或者函数.也就是说对象是一组没有特定顺序的值.  

#### 理解对象
对象数据属性(property)具有的特性(attribute)有:
+ [[Configurable]] 是否能通过delete删除属性从而重新定义属性,默认为true
+ [[Enumerable]] 是否能通过for-in循环返回属性,默认为true
+ [[Writable]] 能否修改属性的值,默认为true
+ [[Value]] 属性的数据值,默认为undefined

访问器属性,getter和setter函数,getter用来读取,setter用来写入,其特性有:
+ [[Configurable]] 表示是否能够通过delete删除属性从而重新定义属性.默认为true
+ [[Enumerable]] 表示是否能通过for-in循环返回属性,默认为true
+ [[Get]] 在读取属性的时候调用的函数,默认为undefined
+ [[Setter]] 在写入属性的时候调用的函数,默认为undefined

访问器属性不能直接定义,只能通过`Object.defineProperty()`来定义.
```javascript
var book= {
  _year:2004,
  edition:1
};
Object.defineProperty(book,'year',{
  get: function(){
    return this._year;
  },
  set: function(newValue){
    if(newValue > 2004){
      this._year =newValue;
      this.edition += newValue - 2004;
    }
  }
});
book.year=2005;
book.edition; // 2
```
定义多个属性:
```javascript
//
var book = {};
Object.defineProperties(book,{
  _year: {
    value: 2004,
  },
  edition: {
    value: 1,
  },
  year:{
    get: function(){
      return this._year;
    },
    set: function(newValue){
      if(newValue > 2004){
        this._year = newValue;
        this.edition += newValue -2004;
      }
    }
  }
});
```

#### 创建对象

###### 工厂模式
一种广为人知的设计模式,其抽象了创建具体对象的过程.工厂模式解决了创建多个相似对象的问题,但是却没有解决对象识别的问题.
```JavaScript
function createPerson(name,age,job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function(){
    alert(this.name);
  }
  return o;
}
var person1 = createPerson('Nicholas',29,"Software Engineer");
var person2 = createPerson('Greg',33,"Doctor");
```

###### 构造函数模式
构造模式可以创建特定类型的对象.
+ 构造函数跟一般函数并没有什么区别
+ 构造函数的主要问题是每个方法都要在每个实例上重新创建一遍
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function(){
    alert(this.name);
  }
}
var person1 = new Person('Nicholas',29,"Software Engineer");
var person2 = new Person('Greg',33,'Doctor');
```

###### 原型模式
我们创建的每一个函数都有一个prototype(原型)属性,这个属性是一个指针,指向一个对象,而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法.使用原型模式的好处是可以让所有对象实例共享它所包含的属性和方法.
```javascript
function Person(){}
Person.prototype.name = 'Nicholas';
Person.prototype.age = 29;
Person.prototype.job = 'Software engineer';
Person.prototype.sayName = function(){
  alert(this.name);
};

var person1 = new Person();
person1.sayName(); // Nicholas
var person2 = new Person();
person2.sayName(); // Nicholas
alert(person1.sayName == person2.sayName); // true

// Object.getPrototypeOf() 用来获取一个对象的原型
Object.getPrototypeOf(person1) == Person.prototype; // true

// 实例定义的属性或者方法可以覆盖原型中的同名属性或者方法

// 原型与in操作符
// in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例或者原型中
"name" in person1; // true

// 可以用for-in 来枚举对象的属性(可枚举的属性),但是ECMAScript 5中有更好的获取方法Object.keys()
Object.keys(person1);

// 更简单的原型语法
function Person(){}
Person.prototype = {
  constructor: Person,
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  syaName: function(){
    alert(this.name);
  }
};

// 实例的原型仅指向原型,而不是指向构造函数
// javascript中所有原生的引用类型都是使用原型模式创建,比如 Object,Array,String

// 原型模式的缺点
// 原型中的所有属性被很多实例共享,对于包含基本值得属性影响不大,但是对于那些包含引用类型值得属性来说,问题非常突出
// 一个实例修改该引用类型的属性,会导致其他实例上该属性值同步发生变化,因为部分实例有属于自己的属性
// 这也导致了很少有人单独使用原型模式

```
###### 组合使用构造函数模式和原型模式
在这种模式下,构造函数模式用来定义实例属性,而原型模式用来定义方法和共享属性,结果每个实例都会有自己的一份实例属性的副本,但同时又共享着对方的引用,最大限度的节省了内存.该模式是目前在ECMAScript中使用最广泛,认同度最高的一种创建自定义对象的方法.
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.friends = ['Shelby','Court'];
}
Person.prototype = {
  constructor : Person,
  sayName : function(){
    alert(this.name);
  }
};

var person1 = new Person('Nicholas',29,'Software Engineer');
var person2 = new Person('Greg',27,'Doctor');

person1.friends.push('Van');
person1.friends; // ["Shelby", "Court", "Van"]
person2.friends; // ["Shelby", "Court"]
```

###### 动态原型模式
把所有的信息都封装在构造函数中,比较完美,不过不能用对象字面量重写原型.
```javascript
function Person(name,age,job){
  this.name = name;
  this.age = age;
  this.job = job;

  if(typeof this.sayName != 'function'){
    Person.prototype.sayName = function(){
      alert(this.name);
    };
  }
}
```

###### 寄生构造函数模式
用的不多,不在介绍

###### 稳妥构造函数模式
用的不都,听说很安全,适合在某些安全执行环境中使用,这里不在介绍了

#### 继承
由于ECMAscript中函数没有签名,无法实现接口继承,只能用实现继承,实现继承主要依据原型链来实现.

###### 原型链
原型链的概念:让一个引用类型的原型等于另外一个引用类型的实例,而另外一个引用类型的原型又指向另外一个引用类型的实例,如此层层递进,就构成了实例与原型的链条.  
原型链实现继承的问题有:
+ 包含引用类型的原型属性会被所有实例共享
+ 创建子类型的实例时,不能向超类型中传递参数

###### 借用构造函数
基本思想是在子类构造函数的内部调用超类构造函数.
```javascript
function SuperType(name){
  this.name = name;
}
function SubType(){
  SuperType.call(this,'Nicholas');
  // 实例属性
  this.age = 29;
}
var instance = new SubType();
instance.name; // Nicholas
instance.age; // 29
```
借用构造函数的问题:
+ 方法都在构造函数中定义,因此函数复用就无从谈起
+ 在超类型的原型中定义的方法,对子类而言也是不可见的,结果所有类型都只能使用构造函数模式

###### 组合继承(combination inheritance)
组合继承也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥两者之长的一种继承模式.背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承.
```javascript
function SuperType(name){
  this.name = name;
  this.colors = ['red','blue','green'];
}

SuperType.prototype.sayName=function(){
  alert(this.name);
}

function SubType(name,age){
  // 继承属性
  SuperType.call(this,name);
  this.age = age;
}

// 继承方法
SubType.prototype = new SuperType();

SubType.prototype.sayAge = function(){
  alert(this.age);
}

var instance1 = new SubType('Nicholas',29);
instance1.colors.push('black');
instance1.colors; // red,blue,green,black,
instance1.sayName(); // Nicholas
instance1.sayAge(); // 29

var instance2 = new SubType('Gred',27);
instance2.colors; // red,blue,green;
instance2.sayName(); // Nicholas
instance2.sayAge(); // 27
```
组合继承避免了原型链和借用构造函数的缺陷,融合了他们的优点,成为Javascript中最常用的继承模式,而且可以用`instanceof`和`isPrototypeOf()`也能够用于识别基于组合继承创建的对象.

###### 原型式继承
思想是借助原型基于已有的对象创建新对象.
```javascript
// 用如下函数来实现
function object(o){
  function F(){}
  F.prototype = o;
  return new F();
}
// 这种原型式继承,要求你必须有一个对象可以作为另一个对象的基础.
var person = {
  name: 'Nicholas',
  friends: ["Shelby","Court","Van"]
};

var anotherPerson = object(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = object(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

person.friends; // Shelby,Court,Van,Rob,Barbie
anotherPerson.friends; // Shelby,Court,Van,Rob,Barbie
```
ECMAScript 5 新增的`Object.create()`方法规范化了原型式继承,该方法类似于上面的`object()`方法.
```Javascript
var person = {
  name: 'Nicholas',
  friends: ["Shelby","Court","Van"]
};

var anotherPerson = Object.create(person);
anotherPerson.name = 'Greg';
anotherPerson.friends.push('Rob');

var yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = 'Linda';
yetAnotherPerson.friends.push('Barbie');

person.friends; // Shelby,Court,Van,Rob,Barbie
anotherPerson.friends; // Shelby,Court,Van,Rob,Barbie
```
在没有必要兴师动众地创建构造函数,而只想让一个对象与另一个对象保持类似的情况下,原型式继承式完全胜任的.不过在包含引用类型的属性时始终会共享相同的值.

###### 寄生式继承
寄生式继承是与原型式继承紧密相关的一种思路,其思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式增强对象,最后再像真正地是他做了所有工作一样返回对象.
```javascript
function createAnother(original){
  var clone = object(original);
  clone.sayHi = function(){
    alert('Hi');
  };
  return clone;
}
```
由于该模式降低了函数的复用导致效率低下为其最大弊端.

###### 寄生组合式继承
由于组合继承无论在什么情况下,都会调用两次超类构造函数,所有有人提出来寄生组合式继承来解决这一个问题.  
所谓寄生组合继承,即通过借用构造函数来继承属性,通过原型链的混成形式来继承方法.其背后的思路是:不必为了指定类型的原型而调用超类型的构造函数,我们所需要的无非就是超类型原型的一个副本而已.
```javascript
function inheritPrototype(SubType,SuperType){
  var prototype = SuperType.prototype;
  prototype.constructor = SubType;
  SubType.prototype = prototype;
}

// 例子
function SuperType(name){
  this.name = name;
  this.colors = ['red','blue','green'];
}

SuperType.prototype.sayName = function(){
  alert(this.name);
};

function SubType(name,age){
  SuperType.call(this,name);
  this.age = age;
}

inheritPrototype(SubType,SuperType);

SubType.prototype.sayAge = function(){
  alert(this.age);
};

var sub = new SubType('Nicholas',29);
sub.sayName(); // Nicholas
sub.sayAge(); // 29
sub.colors.push('black');
sub.colors; // red,blue,green,black
```
开发人员普遍认为寄生组合式继承式引用类型最理想的继承范式.YUI就是使用寄生组合继承.

#### 第六章总结
ECMAScript支持面向对象(OO)编程,但不使用类或者接口,对象在代码执行过程中创建和增强,因此具有动态性而非严格定义的实体.在没有类的情况下,可以采用下列模式来创建对象.
+ 工厂模式,使用简单的函数创建对象,为对象添加属性和方法,然后返回对象.这个模式后来被构造函数模式替代.
+ 构造函数模式,可以创建自定义引用类型,可以像创建内置对象实例一样使用new操作符.该模式的缺点是它的每个成员都无法得到复用,包括函数.由于函数可以不局限于任何对象(与对象是松散耦合),因此没有理由不在多个对象间共享函数.
+ 原型模式,使用构造函数的prototype属性来指定那些应该共享的属性和方法.组合使用构造函数模式和原型模式时,使用构造函数定义实例属性,而使用原型定义共享的属性和方法.

JavaScript主要使用原型链实现继承,原型链的构建是通过一个类的实例赋值给另一个构造函数的原型来实现的.这样,子类型就能够访问超类型中所有属性和方法,这一点与基于类的继承很相似.原型链的问题是对象实例共享所有继承的属性和方法,因此不宜单独使用.解决这个问题的技术是使用借用构造函数,即在子类构造函数的内部调用超类构造函数,这样就可以做到每个实例都具有自己的属性,同时还支持只使用构造函数模式来定义类型.使用最多的继承模式是组合继承,这种模式使用原型链继承共享的属性和方法,而通过借用构造函数继承实例属性.此外,还有以下几种继承模式:
+ 原型式继承,可以在不必预先定义构造函数的情况下实现继承,其本质是执行对给定对象的浅复制.而复制的副本还可以进一步改造.
+ 寄生式继承,与原型式继承非常相似,也是基于某些对象或者信息创建一个对象,然后增强对象,最后在返回对象.为了解决组合继承模式多次调用超类构造函数而导致的低效率问题,可以将这个模式与组合继承一起使用.
+ 寄生组合式继承,集寄生式继承和组合式继承的优点与一身,是实现基于类继承的最有效方式.
